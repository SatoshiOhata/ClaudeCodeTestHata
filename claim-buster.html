<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>クレームバスター - カスタマーサポートシューティング</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  background: #0a0a2e;
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 100vh;
  font-family: 'Segoe UI', 'Hiragino Sans', 'Meiryo', sans-serif;
  overflow: hidden;
}
#gameContainer {
  position: relative;
  width: 480px;
  height: 720px;
}
canvas {
  display: block;
  border: 2px solid #3a3aff;
  border-radius: 8px;
  box-shadow: 0 0 30px rgba(58, 58, 255, 0.3);
}
#ui-overlay {
  position: absolute;
  top: 0; left: 0;
  width: 100%; height: 100%;
  pointer-events: none;
}
#hud {
  position: absolute;
  top: 8px; left: 12px; right: 12px;
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  color: #fff;
  font-size: 14px;
  pointer-events: none;
  z-index: 10;
}
#hud .stat { text-shadow: 0 0 6px rgba(0,0,0,0.8); }
#satisfaction-bar {
  width: 120px; height: 12px;
  background: #333;
  border-radius: 6px;
  overflow: hidden;
  margin-top: 4px;
}
#satisfaction-fill {
  width: 100%; height: 100%;
  background: linear-gradient(90deg, #ff4444, #ffaa00, #44ff44);
  border-radius: 6px;
  transition: width 0.3s;
}
#weapon-indicator {
  position: absolute;
  bottom: 80px; left: 50%;
  transform: translateX(-50%);
  color: #fff;
  font-size: 12px;
  text-align: center;
  pointer-events: none;
  z-index: 10;
  text-shadow: 0 0 6px rgba(0,0,0,0.8);
  background: rgba(0,0,0,0.5);
  padding: 4px 12px;
  border-radius: 12px;
}
#start-screen, #gameover-screen, #clear-screen {
  position: absolute;
  top: 0; left: 0; width: 100%; height: 100%;
  display: flex; flex-direction: column;
  justify-content: center; align-items: center;
  background: rgba(10, 10, 46, 0.92);
  color: #fff;
  z-index: 100;
  pointer-events: auto;
}
#start-screen h1 {
  font-size: 36px;
  margin-bottom: 8px;
  background: linear-gradient(135deg, #ff6b6b, #ffd93d, #6bcb77, #4d96ff);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
}
#start-screen .subtitle {
  font-size: 14px;
  color: #aaa;
  margin-bottom: 30px;
}
.btn {
  padding: 14px 40px;
  font-size: 18px;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  font-weight: bold;
  transition: transform 0.15s, box-shadow 0.15s;
  pointer-events: auto;
}
.btn:hover { transform: scale(1.05); box-shadow: 0 0 20px rgba(255,255,255,0.3); }
.btn-start {
  background: linear-gradient(135deg, #4d96ff, #6bcb77);
  color: #fff;
  margin-bottom: 16px;
}
.btn-retry {
  background: linear-gradient(135deg, #ff6b6b, #ffd93d);
  color: #fff;
  margin-bottom: 16px;
}
#gameover-screen h2 { font-size: 32px; color: #ff6b6b; margin-bottom: 10px; }
#clear-screen h2 { font-size: 32px; color: #6bcb77; margin-bottom: 10px; }
.final-score { font-size: 20px; margin-bottom: 20px; }
.controls-info {
  font-size: 12px;
  color: #888;
  margin-top: 20px;
  text-align: center;
  line-height: 1.8;
}
.controls-info kbd {
  background: #333;
  padding: 2px 8px;
  border-radius: 4px;
  border: 1px solid #555;
  font-size: 11px;
}
.wave-announce {
  position: absolute;
  top: 50%; left: 50%;
  transform: translate(-50%, -50%);
  font-size: 28px;
  color: #ffd93d;
  font-weight: bold;
  text-shadow: 0 0 20px rgba(255, 217, 61, 0.5);
  pointer-events: none;
  z-index: 50;
  opacity: 0;
  transition: opacity 0.3s;
}
</style>
</head>
<body>

<div id="gameContainer">
  <canvas id="gameCanvas" width="480" height="720"></canvas>
  <div id="ui-overlay">
    <div id="hud">
      <div>
        <div class="stat" id="score-display">SCORE: 0</div>
        <div class="stat" id="combo-display">COMBO: 0</div>
      </div>
      <div>
        <div class="stat" id="wave-display">WAVE 1</div>
        <div class="stat">顧客満足度</div>
        <div id="satisfaction-bar"><div id="satisfaction-fill"></div></div>
      </div>
    </div>
    <div id="weapon-indicator"></div>
    <div class="wave-announce" id="wave-announce"></div>
  </div>

  <div id="start-screen">
    <h1>クレームバスター</h1>
    <div class="subtitle">~ カスタマーサポートシューティング ~</div>
    <button class="btn btn-start" onclick="startGame()">ゲームスタート</button>
    <div class="controls-info">
      <kbd>←</kbd> <kbd>→</kbd> 移動 &nbsp; <kbd>Space</kbd> 発射<br>
      <kbd>1</kbd><kbd>2</kbd><kbd>3</kbd><kbd>4</kbd> 回答タイプ切替<br>
      適切な回答で問い合わせを解決しよう!
    </div>
  </div>

  <div id="gameover-screen" style="display:none;">
    <h2>GAME OVER</h2>
    <div>顧客満足度が0になりました...</div>
    <div class="final-score" id="final-score"></div>
    <button class="btn btn-retry" onclick="startGame()">リトライ</button>
  </div>

  <div id="clear-screen" style="display:none;">
    <h2>ALL CLEAR!</h2>
    <div>全ての問い合わせを解決しました!</div>
    <div class="final-score" id="clear-score"></div>
    <button class="btn btn-start" onclick="startGame()">もう一度プレイ</button>
  </div>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const W = canvas.width;
const H = canvas.height;

// --- Game Constants ---
const RESPONSE_TYPES = [
  { id: 0, name: '丁寧な謝罪',   color: '#ff6b6b', key: '1', symbol: '謝' },
  { id: 1, name: '技術サポート', color: '#4d96ff', key: '2', symbol: '技' },
  { id: 2, name: '返金対応',     color: '#6bcb77', key: '3', symbol: '返' },
  { id: 3, name: 'FAQ案内',      color: '#ffd93d', key: '4', symbol: 'F' },
];

const COMPLAINT_TYPES = [
  { id: 0, text: '対応が悪い!',       bestResponse: 0, speed: 1.0, hp: 1, points: 100, color: '#ff4444' },
  { id: 1, text: 'バグがある!',       bestResponse: 1, speed: 0.8, hp: 1, points: 100, color: '#4488ff' },
  { id: 2, text: '返品したい!',       bestResponse: 2, speed: 0.9, hp: 1, points: 100, color: '#44cc66' },
  { id: 3, text: '使い方がわからん!', bestResponse: 3, speed: 0.7, hp: 1, points: 100, color: '#ddcc33' },
  { id: 4, text: '遅すぎる!',         bestResponse: 0, speed: 1.5, hp: 1, points: 150, color: '#ff6644' },
  { id: 5, text: 'データ消えた!',     bestResponse: 1, speed: 1.2, hp: 2, points: 200, color: '#6666ff' },
  { id: 6, text: '二重請求された!',   bestResponse: 2, speed: 1.1, hp: 2, points: 200, color: '#33dd88' },
  { id: 7, text: 'ログインできない!', bestResponse: 1, speed: 1.0, hp: 2, points: 150, color: '#8888ff' },
];

const BOSS_DATA = {
  text: 'モンスタークレーマー',
  hp: 30,
  speed: 0.3,
  points: 2000,
  color: '#ff00ff',
  width: 120,
  height: 70,
};

// --- Game State ---
let game = {};

function initGame() {
  game = {
    state: 'playing',
    score: 0,
    combo: 0,
    maxCombo: 0,
    satisfaction: 100,
    wave: 1,
    maxWave: 10,
    waveTimer: 0,
    waveDelay: 180,
    spawnTimer: 0,
    spawnInterval: 60,
    enemiesSpawned: 0,
    enemiesPerWave: 8,
    waveCleared: false,
    bossActive: false,
    player: {
      x: W / 2,
      y: H - 60,
      width: 40,
      height: 48,
      speed: 5,
      selectedWeapon: 0,
      fireRate: 12,
      fireTimer: 0,
      invincible: 0,
    },
    bullets: [],
    enemies: [],
    particles: [],
    texts: [],
    keys: {},
    shakeTimer: 0,
    shakeIntensity: 0,
  };
}

// --- Input ---
document.addEventListener('keydown', e => {
  game.keys[e.code] = true;
  if (['Digit1','Digit2','Digit3','Digit4'].includes(e.code)) {
    game.player.selectedWeapon = parseInt(e.code.replace('Digit','')) - 1;
  }
  if (e.code === 'Space') e.preventDefault();
});
document.addEventListener('keyup', e => { game.keys[e.code] = false; });

// --- Spawn ---
function spawnEnemy(type) {
  const t = COMPLAINT_TYPES[type];
  const w = 90 + t.text.length * 4;
  const enemy = {
    x: Math.random() * (W - w - 20) + 10,
    y: -50,
    width: w,
    height: 44,
    type: type,
    text: t.text,
    bestResponse: t.bestResponse,
    speed: t.speed * (1 + game.wave * 0.05),
    hp: t.hp,
    maxHp: t.hp,
    points: t.points,
    color: t.color,
    isBoss: false,
    wobble: Math.random() * Math.PI * 2,
    wobbleSpeed: 0.02 + Math.random() * 0.02,
    wobbleAmp: 15 + Math.random() * 20,
    flash: 0,
  };
  game.enemies.push(enemy);
}

function spawnBoss() {
  const b = BOSS_DATA;
  const enemy = {
    x: W / 2 - b.width / 2,
    y: -80,
    width: b.width,
    height: b.height,
    type: -1,
    text: b.text,
    bestResponse: -1,
    speed: b.speed,
    hp: b.hp + game.wave * 5,
    maxHp: b.hp + game.wave * 5,
    points: b.points,
    color: b.color,
    isBoss: true,
    wobble: 0,
    wobbleSpeed: 0.015,
    wobbleAmp: 60,
    flash: 0,
    attackTimer: 0,
    attackInterval: 90,
  };
  game.enemies.push(enemy);
  game.bossActive = true;
}

function fireBullet() {
  const p = game.player;
  const resp = RESPONSE_TYPES[p.selectedWeapon];
  game.bullets.push({
    x: p.x,
    y: p.y - p.height / 2,
    width: 8,
    height: 16,
    speed: 8,
    type: p.selectedWeapon,
    color: resp.color,
    symbol: resp.symbol,
    fromBoss: false,
  });
}

function fireBossBullet(boss) {
  const angle = Math.atan2(game.player.y - boss.y, game.player.x - boss.x);
  const texts = ['まだ!?', '早くしろ!', '責任者出せ!', '訴えるぞ!', 'ありえない!'];
  game.bullets.push({
    x: boss.x + boss.width / 2,
    y: boss.y + boss.height,
    width: 12,
    height: 12,
    speed: 3,
    vx: Math.cos(angle) * 3,
    vy: Math.sin(angle) * 3,
    color: '#ff00ff',
    symbol: texts[Math.floor(Math.random() * texts.length)],
    fromBoss: true,
  });
}

// --- Particles ---
function spawnParticles(x, y, color, count) {
  for (let i = 0; i < count; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = 1 + Math.random() * 3;
    game.particles.push({
      x, y,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      life: 30 + Math.random() * 20,
      maxLife: 50,
      color: color,
      size: 2 + Math.random() * 4,
    });
  }
}

function spawnFloatText(x, y, text, color) {
  game.texts.push({ x, y, text, color, life: 60 });
}

// --- Collision ---
function rectsOverlap(a, b) {
  return a.x - a.width/2 < b.x + b.width/2 &&
         a.x + a.width/2 > b.x - b.width/2 &&
         a.y - a.height/2 < b.y + b.height/2 &&
         a.y + a.height/2 > b.y - b.height/2;
}

// --- Wave Management ---
function announceWave(text) {
  const el = document.getElementById('wave-announce');
  el.textContent = text;
  el.style.opacity = '1';
  setTimeout(() => { el.style.opacity = '0'; }, 2000);
}

function startWave() {
  game.waveCleared = false;
  game.enemiesSpawned = 0;
  game.spawnTimer = 0;
  const isBossWave = game.wave % 5 === 0;
  if (isBossWave) {
    game.enemiesPerWave = 3;
    announceWave(`WAVE ${game.wave} - BOSS 出現!`);
  } else {
    game.enemiesPerWave = 6 + game.wave * 2;
    announceWave(`WAVE ${game.wave}`);
  }
  game.spawnInterval = Math.max(20, 60 - game.wave * 3);
}

// --- Update ---
function update() {
  if (game.state !== 'playing') return;

  const p = game.player;
  const keys = game.keys;

  // Player movement
  if (keys['ArrowLeft'] || keys['KeyA'])  p.x -= p.speed;
  if (keys['ArrowRight'] || keys['KeyD']) p.x += p.speed;
  p.x = Math.max(p.width / 2, Math.min(W - p.width / 2, p.x));

  // Firing
  p.fireTimer--;
  if (keys['Space'] && p.fireTimer <= 0) {
    fireBullet();
    p.fireTimer = p.fireRate;
  }

  if (p.invincible > 0) p.invincible--;

  // Wave management
  if (game.waveTimer > 0) {
    game.waveTimer--;
    if (game.waveTimer === 0) startWave();
  } else {
    // Spawning
    game.spawnTimer--;
    if (game.spawnTimer <= 0 && game.enemiesSpawned < game.enemiesPerWave) {
      const isBossWave = game.wave % 5 === 0;
      if (isBossWave && game.enemiesSpawned === game.enemiesPerWave - 1 && !game.bossActive) {
        spawnBoss();
      } else {
        const available = Math.min(COMPLAINT_TYPES.length, 4 + Math.floor(game.wave / 2));
        spawnEnemy(Math.floor(Math.random() * available));
      }
      game.enemiesSpawned++;
      game.spawnTimer = game.spawnInterval;
    }

    // Check wave clear
    if (game.enemiesSpawned >= game.enemiesPerWave && game.enemies.length === 0 && !game.waveCleared) {
      game.waveCleared = true;
      game.bossActive = false;
      if (game.wave >= game.maxWave) {
        game.state = 'clear';
        showClearScreen();
        return;
      }
      game.wave++;
      game.waveTimer = game.waveDelay;
      // Bonus for clearing wave
      const bonus = 500 * game.wave;
      game.score += bonus;
      spawnFloatText(W / 2, H / 2, `WAVE CLEAR! +${bonus}`, '#ffd93d');
      game.satisfaction = Math.min(100, game.satisfaction + 5);
    }
  }

  // Update bullets
  for (let i = game.bullets.length - 1; i >= 0; i--) {
    const b = game.bullets[i];
    if (b.fromBoss) {
      b.x += b.vx;
      b.y += b.vy;
    } else {
      b.y -= b.speed;
    }
    // Remove off-screen
    if (b.y < -20 || b.y > H + 20 || b.x < -20 || b.x > W + 20) {
      game.bullets.splice(i, 1);
      continue;
    }
    // Boss bullet hits player
    if (b.fromBoss && p.invincible <= 0) {
      const dist = Math.hypot(b.x - p.x, b.y - p.y);
      if (dist < 24) {
        game.bullets.splice(i, 1);
        game.satisfaction -= 5;
        game.combo = 0;
        p.invincible = 60;
        game.shakeTimer = 10;
        game.shakeIntensity = 4;
        spawnParticles(p.x, p.y, '#ff4444', 8);
        checkSatisfaction();
        continue;
      }
    }
    // Player bullet hits enemy
    if (!b.fromBoss) {
      for (let j = game.enemies.length - 1; j >= 0; j--) {
        const e = game.enemies[j];
        const ex = e.x + e.width / 2;
        const ey = e.y + e.height / 2;
        if (b.x > e.x && b.x < e.x + e.width && b.y > e.y && b.y < e.y + e.height) {
          game.bullets.splice(i, 1);
          // Check if matching response
          const isMatch = e.isBoss || b.type === e.bestResponse;
          const dmg = isMatch ? 2 : 1;
          e.hp -= dmg;
          e.flash = 8;

          if (e.hp <= 0) {
            // Enemy destroyed
            if (isMatch && !e.isBoss) {
              game.combo++;
              const comboBonus = Math.floor(e.points * (1 + game.combo * 0.1));
              game.score += comboBonus;
              spawnFloatText(ex, ey, `+${comboBonus} PERFECT!`, '#ffd93d');
              game.satisfaction = Math.min(100, game.satisfaction + 2);
            } else if (e.isBoss) {
              game.score += e.points;
              game.combo += 5;
              spawnFloatText(ex, ey, `+${e.points} BOSS撃破!`, '#ff00ff');
              game.satisfaction = Math.min(100, game.satisfaction + 10);
              game.shakeTimer = 20;
              game.shakeIntensity = 8;
            } else {
              game.combo = 0;
              game.score += Math.floor(e.points * 0.5);
              spawnFloatText(ex, ey, `+${Math.floor(e.points * 0.5)}`, '#aaa');
              game.satisfaction -= 3;
            }
            if (game.combo > game.maxCombo) game.maxCombo = game.combo;
            spawnParticles(ex, ey, e.color, e.isBoss ? 30 : 12);
            game.enemies.splice(j, 1);
          } else {
            spawnParticles(b.x, b.y, b.color, 3);
          }
          break;
        }
      }
    }
  }

  // Update enemies
  for (let i = game.enemies.length - 1; i >= 0; i--) {
    const e = game.enemies[i];
    e.wobble += e.wobbleSpeed;
    if (e.isBoss) {
      // Boss movement pattern
      if (e.y < 60) {
        e.y += e.speed;
      }
      e.x = W / 2 - e.width / 2 + Math.sin(e.wobble) * e.wobbleAmp;
      // Boss attacks
      e.attackTimer++;
      if (e.attackTimer >= e.attackInterval) {
        e.attackTimer = 0;
        fireBossBullet(e);
      }
    } else {
      e.y += e.speed;
      e.x += Math.sin(e.wobble) * 0.5;
    }
    if (e.flash > 0) e.flash--;

    // Enemy reaches bottom
    if (!e.isBoss && e.y > H + 10) {
      game.enemies.splice(i, 1);
      game.satisfaction -= 10;
      game.combo = 0;
      game.shakeTimer = 8;
      game.shakeIntensity = 3;
      spawnFloatText(W / 2, H - 80, '未解決! -10', '#ff4444');
      checkSatisfaction();
    }
  }

  // Update particles
  for (let i = game.particles.length - 1; i >= 0; i--) {
    const pt = game.particles[i];
    pt.x += pt.vx;
    pt.y += pt.vy;
    pt.vy += 0.05;
    pt.life--;
    if (pt.life <= 0) game.particles.splice(i, 1);
  }

  // Update floating texts
  for (let i = game.texts.length - 1; i >= 0; i--) {
    game.texts[i].y -= 1;
    game.texts[i].life--;
    if (game.texts[i].life <= 0) game.texts.splice(i, 1);
  }

  // Screen shake
  if (game.shakeTimer > 0) game.shakeTimer--;

  // Update HUD
  document.getElementById('score-display').textContent = `SCORE: ${game.score}`;
  document.getElementById('combo-display').textContent = `COMBO: ${game.combo}`;
  document.getElementById('wave-display').textContent = `WAVE ${game.wave}`;
  document.getElementById('satisfaction-fill').style.width = `${Math.max(0, game.satisfaction)}%`;

  const wr = RESPONSE_TYPES[p.selectedWeapon];
  document.getElementById('weapon-indicator').innerHTML =
    RESPONSE_TYPES.map((r, i) =>
      `<span style="color:${r.color};${i===p.selectedWeapon?'font-weight:bold;text-decoration:underline;font-size:14px;':'opacity:0.5;'}">[${r.key}]${r.name}</span>`
    ).join('  ');
}

function checkSatisfaction() {
  if (game.satisfaction <= 0) {
    game.satisfaction = 0;
    game.state = 'gameover';
    showGameOverScreen();
  }
}

// --- Draw ---
function draw() {
  ctx.save();

  // Screen shake
  if (game.shakeTimer > 0) {
    const sx = (Math.random() - 0.5) * game.shakeIntensity;
    const sy = (Math.random() - 0.5) * game.shakeIntensity;
    ctx.translate(sx, sy);
  }

  // Background
  ctx.fillStyle = '#0d0d30';
  ctx.fillRect(0, 0, W, H);

  // Grid background
  ctx.strokeStyle = 'rgba(58, 58, 255, 0.08)';
  ctx.lineWidth = 1;
  for (let x = 0; x < W; x += 40) {
    ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke();
  }
  for (let y = 0; y < H; y += 40) {
    ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(W, y); ctx.stroke();
  }

  // Draw particles
  for (const pt of game.particles) {
    const alpha = pt.life / pt.maxLife;
    ctx.globalAlpha = alpha;
    ctx.fillStyle = pt.color;
    ctx.beginPath();
    ctx.arc(pt.x, pt.y, pt.size * alpha, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;

  // Draw enemies
  for (const e of game.enemies) {
    ctx.save();
    if (e.flash > 0) {
      ctx.globalAlpha = 0.5 + Math.sin(e.flash * 2) * 0.5;
    }

    const ex = e.x;
    const ey = e.y;

    // Speech bubble body
    const r = 10;
    ctx.fillStyle = e.flash > 0 ? '#ffffff' : e.color;
    ctx.beginPath();
    ctx.moveTo(ex + r, ey);
    ctx.lineTo(ex + e.width - r, ey);
    ctx.quadraticCurveTo(ex + e.width, ey, ex + e.width, ey + r);
    ctx.lineTo(ex + e.width, ey + e.height - r);
    ctx.quadraticCurveTo(ex + e.width, ey + e.height, ex + e.width - r, ey + e.height);
    // Tail
    ctx.lineTo(ex + e.width * 0.4, ey + e.height);
    ctx.lineTo(ex + e.width * 0.3, ey + e.height + 10);
    ctx.lineTo(ex + e.width * 0.25, ey + e.height);
    ctx.lineTo(ex + r, ey + e.height);
    ctx.quadraticCurveTo(ex, ey + e.height, ex, ey + e.height - r);
    ctx.lineTo(ex, ey + r);
    ctx.quadraticCurveTo(ex, ey, ex + r, ey);
    ctx.closePath();
    ctx.fill();

    // Border
    ctx.strokeStyle = 'rgba(255,255,255,0.3)';
    ctx.lineWidth = 1.5;
    ctx.stroke();

    // Text
    ctx.fillStyle = '#fff';
    ctx.font = e.isBoss ? 'bold 14px sans-serif' : '12px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(e.text, ex + e.width / 2, ey + e.height / 2);

    // HP bar for multi-hp enemies
    if (e.maxHp > 1) {
      const bw = e.width - 10;
      const bh = 4;
      const bx = ex + 5;
      const by = ey - 8;
      ctx.fillStyle = '#333';
      ctx.fillRect(bx, by, bw, bh);
      ctx.fillStyle = e.isBoss ? '#ff00ff' : '#ff4444';
      ctx.fillRect(bx, by, bw * (e.hp / e.maxHp), bh);
    }

    // Best response hint (small icon)
    if (!e.isBoss) {
      const resp = RESPONSE_TYPES[e.bestResponse];
      ctx.fillStyle = resp.color;
      ctx.font = 'bold 10px sans-serif';
      ctx.textAlign = 'right';
      ctx.fillText(resp.symbol, ex + e.width - 4, ey + e.height - 6);
    }

    ctx.restore();
  }

  // Draw bullets
  for (const b of game.bullets) {
    ctx.save();
    if (b.fromBoss) {
      // Boss bullet - angry text
      ctx.fillStyle = b.color;
      ctx.font = 'bold 10px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(b.symbol, b.x, b.y);
      // Glow
      ctx.shadowColor = b.color;
      ctx.shadowBlur = 8;
      ctx.fillText(b.symbol, b.x, b.y);
    } else {
      // Player bullet
      ctx.fillStyle = b.color;
      ctx.shadowColor = b.color;
      ctx.shadowBlur = 6;
      ctx.fillRect(b.x - b.width / 2, b.y - b.height / 2, b.width, b.height);
      // Symbol
      ctx.shadowBlur = 0;
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 8px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(b.symbol, b.x, b.y);
    }
    ctx.restore();
  }

  // Draw player
  const p = game.player;
  ctx.save();
  if (p.invincible > 0 && Math.floor(p.invincible / 4) % 2 === 0) {
    ctx.globalAlpha = 0.4;
  }

  const resp = RESPONSE_TYPES[p.selectedWeapon];

  // Body (person icon)
  ctx.fillStyle = resp.color;
  // Head
  ctx.beginPath();
  ctx.arc(p.x, p.y - 16, 10, 0, Math.PI * 2);
  ctx.fill();
  // Body
  ctx.fillRect(p.x - 12, p.y - 6, 24, 20);
  // Headset
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(p.x, p.y - 20, 12, Math.PI * 0.8, Math.PI * 0.2);
  ctx.stroke();
  ctx.fillStyle = '#fff';
  ctx.beginPath();
  ctx.arc(p.x - 12, p.y - 14, 3, 0, Math.PI * 2);
  ctx.fill();
  // Mic
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(p.x - 12, p.y - 11);
  ctx.lineTo(p.x - 8, p.y - 4);
  ctx.stroke();

  ctx.restore();

  // Draw floating texts
  for (const t of game.texts) {
    ctx.globalAlpha = t.life / 60;
    ctx.fillStyle = t.color;
    ctx.font = 'bold 16px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(t.text, t.x, t.y);
  }
  ctx.globalAlpha = 1;

  ctx.restore();
}

// --- Game Loop ---
let animId;
function gameLoop() {
  update();
  draw();
  animId = requestAnimationFrame(gameLoop);
}

// --- Screens ---
function showGameOverScreen() {
  document.getElementById('gameover-screen').style.display = 'flex';
  document.getElementById('final-score').textContent =
    `最終スコア: ${game.score} | 最大コンボ: ${game.maxCombo} | WAVE ${game.wave}`;
}

function showClearScreen() {
  document.getElementById('clear-screen').style.display = 'flex';
  document.getElementById('clear-score').textContent =
    `最終スコア: ${game.score} | 最大コンボ: ${game.maxCombo}`;
}

function startGame() {
  document.getElementById('start-screen').style.display = 'none';
  document.getElementById('gameover-screen').style.display = 'none';
  document.getElementById('clear-screen').style.display = 'none';

  if (animId) cancelAnimationFrame(animId);

  initGame();
  startWave();
  gameLoop();
}
</script>
</body>
</html>
