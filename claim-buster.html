<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Claim Buster - カスタマーサポート シューティングゲーム</title>
<meta name="description" content="クレームを正しく分類して撃破するカスタマーサポート シューティングゲーム。返金対応、バグ修正、お詫びなど5つのカテゴリで迅速に対応しよう。">
<link rel="canonical" href="https://example.com/claim-buster">
<link rel="icon" href="/favicon.ico">
<meta property="og:type" content="website">
<meta property="og:title" content="Claim Buster - カスタマーサポート シューティングゲーム">
<meta property="og:description" content="クレームを正しく分類して撃破するカスタマーサポート シューティングゲーム。5つのカテゴリで迅速に対応しよう。">
<meta property="og:url" content="https://example.com/claim-buster">
<meta property="og:image" content="https://example.com/ogp-claim-buster.png">
<meta property="og:site_name" content="Claim Buster">
<meta property="og:locale" content="ja_JP">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Claim Buster - カスタマーサポート シューティングゲーム">
<meta name="twitter:description" content="クレームを正しく分類して撃破するカスタマーサポート シューティングゲーム。">
<meta name="twitter:image" content="https://example.com/ogp-claim-buster.png">
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "VideoGame",
  "name": "Claim Buster",
  "description": "クレームを正しく分類して撃破するカスタマーサポート シューティングゲーム",
  "url": "https://example.com/claim-buster",
  "genre": "Arcade",
  "gamePlatform": "Web Browser",
  "operatingSystem": "All",
  "inLanguage": "ja",
  "offers": {
    "@type": "Offer",
    "price": "0",
    "priceCurrency": "JPY"
  }
}
</script>
<style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

:root {
  --bg: #0f172a;
  --surface: #1e293b;
  --surface-hover: #273548;
  --border: rgba(148,163,184,0.15);
  --text: #f1f5f9;
  --text-secondary: #94a3b8;
  --radius: 10px;
  --cat-refund: #ef4444;
  --cat-bug: #3b82f6;
  --cat-apology: #f59e0b;
  --cat-feature: #14b8a6;
  --cat-escalation: #a855f7;
  --hud-height: 56px;
  --toolbar-height: 72px;
}

html { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Hiragino Sans", sans-serif; }
body { background: var(--bg); color: var(--text); min-height: 100vh; font-size: 16px; line-height: 1.6; overflow: hidden; user-select: none; }

.sr-only {
  position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px;
  overflow: hidden; clip: rect(0,0,0,0); white-space: nowrap; border: 0;
}

/* ===== Screens ===== */
.screen { display: none; position: absolute; inset: 0; }
.screen.active { display: flex; }

/* ===== Title Screen ===== */
#title-screen {
  flex-direction: column; align-items: center; justify-content: center;
  background: linear-gradient(180deg, #0f172a 0%, #1a1040 100%);
  gap: 24px; padding: 24px; text-align: center;
}
#title-screen h1 {
  font-size: clamp(28px, 6vw, 52px); font-weight: 900; letter-spacing: -0.03em;
  background: linear-gradient(135deg, #f59e0b, #ef4444, #a855f7);
  -webkit-background-clip: text; -webkit-text-fill-color: transparent;
  background-clip: text;
}
#title-screen .subtitle { color: var(--text-secondary); font-size: clamp(14px, 2.5vw, 18px); max-width: 480px; }
.title-info {
  background: var(--surface); border: 1px solid var(--border); border-radius: var(--radius);
  padding: 20px 24px; max-width: 480px; width: 100%; text-align: left; font-size: 14px;
}
.title-info h2 { font-size: 15px; font-weight: 700; margin-bottom: 8px; color: var(--text); }
.title-info p { color: var(--text-secondary); margin-bottom: 4px; line-height: 1.5; }
.title-info .keys { display: flex; gap: 6px; margin: 8px 0; flex-wrap: wrap; }
.title-info .key {
  display: inline-flex; align-items: center; justify-content: center;
  width: 32px; height: 32px; border-radius: 6px; font-weight: 700; font-size: 14px;
  border: 2px solid; flex-shrink: 0;
}
.title-info .key-label { font-size: 12px; color: var(--text-secondary); }
.high-score-display { color: var(--text-secondary); font-size: 14px; }
.high-score-display span { color: #f59e0b; font-weight: 700; font-size: 18px; }
.btn-start {
  padding: 14px 48px; font-size: 18px; font-weight: 700; border: none; border-radius: 12px;
  background: linear-gradient(135deg, #f59e0b, #ef4444); color: #fff; cursor: pointer;
  transition: transform 0.15s, box-shadow 0.15s; letter-spacing: 0.02em;
}
.btn-start:hover { transform: scale(1.05); box-shadow: 0 8px 32px rgba(245,158,11,0.3); }

/* ===== Game Screen ===== */
#game-screen { flex-direction: column; }
.hud {
  display: flex; align-items: center; justify-content: space-between;
  height: var(--hud-height); padding: 0 16px;
  background: var(--surface); border-bottom: 1px solid var(--border);
  font-size: 14px; font-weight: 600; z-index: 10; flex-shrink: 0;
}
.hud-left, .hud-right { display: flex; align-items: center; gap: 16px; }
.hud-item { display: flex; align-items: center; gap: 6px; }
.hud-label { color: var(--text-secondary); font-weight: 500; }
.hud-value { color: #f59e0b; font-weight: 700; font-size: 16px; min-width: 40px; }
.lives { display: flex; gap: 3px; }
.life-pip {
  width: 12px; height: 12px; border-radius: 50%;
  background: #22c55e; transition: background 0.3s, transform 0.3s;
}
.life-pip.lost { background: #334155; transform: scale(0.7); }
.combo-badge {
  padding: 2px 10px; border-radius: 100px; font-size: 12px; font-weight: 700;
  background: #a855f7; color: #fff; opacity: 0; transition: opacity 0.2s;
}
.combo-badge.visible { opacity: 1; }
.btn-pause {
  background: none; border: 1px solid var(--border); color: var(--text-secondary);
  padding: 4px 12px; border-radius: 6px; cursor: pointer; font-size: 13px;
}

.game-area {
  flex: 1; position: relative; overflow: hidden;
  background: linear-gradient(180deg, #0f172a 0%, #162033 100%);
}
.game-area .deadline {
  position: absolute; bottom: 0; left: 0; right: 0; height: 3px;
  background: linear-gradient(90deg, transparent, #ef4444, transparent);
  opacity: 0.5;
}

/* ===== Toolbar ===== */
.toolbar {
  display: flex; align-items: center; justify-content: center; gap: 8px;
  height: var(--toolbar-height); padding: 0 12px;
  background: var(--surface); border-top: 1px solid var(--border);
  flex-shrink: 0; z-index: 10;
}
.tool-btn {
  display: flex; flex-direction: column; align-items: center; justify-content: center;
  gap: 2px; padding: 6px 14px; border-radius: 8px; border: 2px solid;
  background: transparent; color: var(--text); cursor: pointer;
  font-size: 11px; font-weight: 600; min-width: 80px;
  transition: transform 0.1s, background 0.15s, box-shadow 0.15s; position: relative;
}
.tool-btn .tool-key {
  position: absolute; top: -8px; right: -8px;
  width: 20px; height: 20px; border-radius: 4px; font-size: 11px; font-weight: 700;
  display: flex; align-items: center; justify-content: center;
  background: var(--surface); border: 1px solid var(--border); color: var(--text-secondary);
}
.tool-btn:hover { transform: translateY(-2px); }
.tool-btn:active { transform: scale(0.95); }
.tool-btn.selected { box-shadow: 0 0 20px rgba(255,255,255,0.1); }
.tool-btn[data-cat="refund"] { border-color: var(--cat-refund); }
.tool-btn[data-cat="refund"].selected { background: rgba(239,68,68,0.15); }
.tool-btn[data-cat="bug"] { border-color: var(--cat-bug); }
.tool-btn[data-cat="bug"].selected { background: rgba(59,130,246,0.15); }
.tool-btn[data-cat="apology"] { border-color: var(--cat-apology); }
.tool-btn[data-cat="apology"].selected { background: rgba(245,158,11,0.15); }
.tool-btn[data-cat="feature"] { border-color: var(--cat-feature); }
.tool-btn[data-cat="feature"].selected { background: rgba(20,184,166,0.15); }
.tool-btn[data-cat="escalation"] { border-color: var(--cat-escalation); }
.tool-btn[data-cat="escalation"].selected { background: rgba(168,85,247,0.15); }

/* ===== Claim Bubble ===== */
.claim {
  position: absolute; padding: 10px 14px; border-radius: 12px; max-width: 220px;
  font-size: 13px; line-height: 1.4; font-weight: 500;
  background: var(--surface); border: 2px solid var(--border);
  cursor: pointer; z-index: 5; will-change: transform;
  transition: border-color 0.15s, box-shadow 0.15s;
}
.claim::after {
  content: ''; position: absolute; bottom: -8px; left: 20px;
  width: 0; height: 0; border-left: 8px solid transparent;
  border-right: 8px solid transparent; border-top: 8px solid var(--surface);
}
.claim.selected { border-color: #f59e0b; box-shadow: 0 0 16px rgba(245,158,11,0.3); }
.claim.urgent {
  animation: claim-pulse 0.8s ease-in-out infinite;
  border-color: #ef4444; box-shadow: 0 0 12px rgba(239,68,68,0.3);
}
.claim.boss {
  max-width: 280px; font-size: 15px; font-weight: 700;
  border-width: 3px; border-color: #a855f7;
  box-shadow: 0 0 24px rgba(168,85,247,0.3);
}
.claim .claim-badge {
  display: inline-block; font-size: 10px; font-weight: 700; padding: 1px 6px;
  border-radius: 4px; margin-bottom: 4px; color: #fff;
}
.claim .claim-badge.urgent-badge { background: #ef4444; }
.claim .claim-badge.boss-badge { background: #a855f7; }

@keyframes claim-pulse {
  0%, 100% { transform: var(--tx, translateY(0)); }
  50% { box-shadow: 0 0 24px rgba(239,68,68,0.5); }
}

/* ===== Power-Up ===== */
.powerup {
  position: absolute; width: 44px; height: 44px; border-radius: 50%;
  display: flex; align-items: center; justify-content: center;
  font-size: 22px; cursor: pointer; z-index: 6; will-change: transform;
  animation: powerup-glow 1.2s ease-in-out infinite;
  border: 2px solid rgba(255,255,255,0.3); background: var(--surface);
}
@keyframes powerup-glow {
  0%, 100% { box-shadow: 0 0 8px rgba(255,255,255,0.2); }
  50% { box-shadow: 0 0 20px rgba(255,255,255,0.5); }
}

/* ===== Particles & Effects ===== */
.particle {
  position: absolute; border-radius: 50%; pointer-events: none; z-index: 20;
  will-change: transform, opacity;
}
.score-popup {
  position: absolute; font-size: 18px; font-weight: 800; pointer-events: none; z-index: 20;
  color: #f59e0b; text-shadow: 0 2px 8px rgba(0,0,0,0.5);
  animation: score-float 0.8s ease-out forwards;
}
@keyframes score-float {
  0% { opacity: 1; transform: translateY(0) scale(1); }
  100% { opacity: 0; transform: translateY(-60px) scale(1.3); }
}

.screen-shake { animation: shake 0.3s ease-out; }
@keyframes shake {
  0%, 100% { transform: translateX(0); }
  25% { transform: translateX(-4px); }
  50% { transform: translateX(4px); }
  75% { transform: translateX(-2px); }
}

/* ===== Overlays ===== */
.overlay {
  display: none; position: absolute; inset: 0; z-index: 50;
  background: rgba(15,23,42,0.85); backdrop-filter: blur(4px);
  flex-direction: column; align-items: center; justify-content: center;
  gap: 16px; text-align: center; padding: 24px;
}
.overlay.active { display: flex; }
.overlay h2 { font-size: clamp(22px, 5vw, 36px); font-weight: 800; }
.overlay .stat { color: var(--text-secondary); font-size: 15px; }
.overlay .stat span { color: #f59e0b; font-weight: 700; }
.btn-overlay {
  padding: 10px 32px; font-size: 15px; font-weight: 600; border: none; border-radius: 8px;
  cursor: pointer; transition: transform 0.15s;
}
.btn-overlay:hover { transform: scale(1.05); }
.btn-primary { background: linear-gradient(135deg, #f59e0b, #ef4444); color: #fff; }
.btn-secondary { background: var(--surface); color: var(--text); border: 1px solid var(--border); }
.overlay-buttons { display: flex; gap: 12px; flex-wrap: wrap; justify-content: center; }
.bonus-list { font-size: 14px; color: var(--text-secondary); }
.bonus-list div { margin: 4px 0; }
.bonus-list span { color: #22c55e; font-weight: 700; }

/* ===== Active Power-Up Indicator ===== */
.active-powerups {
  position: absolute; top: 8px; right: 8px; z-index: 15;
  display: flex; flex-direction: column; gap: 4px;
}
.active-powerup-tag {
  padding: 4px 10px; border-radius: 6px; font-size: 11px; font-weight: 700;
  color: #fff; animation: pu-blink 1s ease-in-out infinite;
}
@keyframes pu-blink { 0%, 100% { opacity: 1; } 50% { opacity: 0.6; } }

/* ===== Responsive ===== */
@media (max-width: 1024px) {
  .tool-btn { min-width: 70px; padding: 6px 10px; font-size: 10px; }
}
@media (max-width: 768px) {
  .hud { padding: 0 10px; font-size: 13px; gap: 8px; }
  .hud-item { gap: 4px; }
  .toolbar { gap: 4px; height: 64px; }
  .tool-btn { min-width: 58px; padding: 5px 6px; font-size: 9px; }
  .tool-btn .tool-key { width: 16px; height: 16px; font-size: 9px; top: -6px; right: -6px; }
  .claim { max-width: 180px; font-size: 12px; padding: 8px 10px; }
}
@media (max-width: 480px) {
  .hud-label { display: none; }
  .toolbar { gap: 3px; height: 56px; }
  .tool-btn { min-width: 50px; padding: 4px 4px; font-size: 8px; }
  .claim { max-width: 150px; font-size: 11px; }
  .title-info { padding: 14px 16px; font-size: 13px; }
}
</style>
</head>
<body>

<!-- Title Screen -->
<div id="title-screen" class="screen active">
  <h1>Claim Buster</h1>
  <p class="subtitle">カスタマーサポート担当者となり、降り注ぐクレームを正しく分類して撃破せよ！</p>
  <div class="title-info">
    <h2>操作方法</h2>
    <p>クレーム（吹き出し）をクリックして選択し、正しい対応カテゴリで撃破</p>
    <div class="keys">
      <div><div class="key" style="border-color:var(--cat-refund);color:var(--cat-refund);">1</div><div class="key-label">返金</div></div>
      <div><div class="key" style="border-color:var(--cat-bug);color:var(--cat-bug);">2</div><div class="key-label">バグ</div></div>
      <div><div class="key" style="border-color:var(--cat-apology);color:var(--cat-apology);">3</div><div class="key-label">お詫び</div></div>
      <div><div class="key" style="border-color:var(--cat-feature);color:var(--cat-feature);">4</div><div class="key-label">機能</div></div>
      <div><div class="key" style="border-color:var(--cat-escalation);color:var(--cat-escalation);">5</div><div class="key-label">上席</div></div>
    </div>
    <p>Pキー: 一時停止 / Spaceキー: ゲーム開始</p>
  </div>
  <div class="high-score-display">ハイスコア: <span id="title-highscore">0</span></div>
  <button class="btn-start" id="btn-start">ゲームスタート</button>
</div>

<!-- Game Screen -->
<div id="game-screen" class="screen">
  <div class="hud">
    <div class="hud-left">
      <div class="hud-item"><span class="hud-label">スコア</span><span class="hud-value" id="hud-score">0</span></div>
      <div class="hud-item"><span class="hud-label">Lv</span><span class="hud-value" id="hud-level">1</span></div>
      <div class="combo-badge" id="combo-badge">x1</div>
    </div>
    <div class="hud-right">
      <div class="hud-item"><span class="hud-label">HP</span><div class="lives" id="hud-lives"></div></div>
      <button class="btn-pause" id="btn-pause">Pause</button>
    </div>
  </div>
  <div class="game-area" id="game-area">
    <div class="deadline"></div>
    <div class="active-powerups" id="active-powerups"></div>
  </div>
  <div class="toolbar" id="toolbar">
    <button class="tool-btn" data-cat="refund" style="border-color:var(--cat-refund)">
      <span class="tool-key">1</span>返金対応
    </button>
    <button class="tool-btn" data-cat="bug" style="border-color:var(--cat-bug)">
      <span class="tool-key">2</span>バグ修正
    </button>
    <button class="tool-btn" data-cat="apology" style="border-color:var(--cat-apology)">
      <span class="tool-key">3</span>お詫び
    </button>
    <button class="tool-btn" data-cat="feature" style="border-color:var(--cat-feature)">
      <span class="tool-key">4</span>機能提案
    </button>
    <button class="tool-btn" data-cat="escalation" style="border-color:var(--cat-escalation)">
      <span class="tool-key">5</span>上席対応
    </button>
  </div>

  <!-- Pause Overlay -->
  <div class="overlay" id="pause-overlay">
    <h2>一時停止</h2>
    <div class="overlay-buttons">
      <button class="btn-overlay btn-primary" id="btn-resume">再開</button>
      <button class="btn-overlay btn-secondary" id="btn-to-title">タイトルへ</button>
    </div>
  </div>

  <!-- Level Clear Overlay -->
  <div class="overlay" id="level-clear-overlay">
    <h2 id="clear-title">Wave 1 クリア！</h2>
    <div class="bonus-list" id="bonus-list"></div>
    <div class="stat">スコア: <span id="clear-score">0</span></div>
    <button class="btn-overlay btn-primary" id="btn-next-wave">次のWaveへ</button>
  </div>

  <!-- Game Over Overlay -->
  <div class="overlay" id="gameover-overlay">
    <h2 style="color:#ef4444;">ゲームオーバー</h2>
    <div class="stat">最終スコア: <span id="go-score">0</span></div>
    <div class="stat">到達レベル: <span id="go-level">1</span></div>
    <div class="stat">ハイスコア: <span id="go-highscore">0</span></div>
    <div id="go-newrecord" style="color:#f59e0b;font-weight:700;font-size:18px;display:none;">NEW RECORD!</div>
    <div class="overlay-buttons">
      <button class="btn-overlay btn-primary" id="btn-retry">リトライ</button>
      <button class="btn-overlay btn-secondary" id="btn-go-title">タイトルへ</button>
    </div>
  </div>
</div>

<script>
(function() {
'use strict';

// ===== Constants =====
const CATEGORIES = ['refund', 'bug', 'apology', 'feature', 'escalation'];
const CAT_LABELS = { refund: '返金対応', bug: 'バグ修正', apology: 'お詫び', feature: '機能提案', escalation: '上席対応' };
const CAT_COLORS = { refund: '#ef4444', bug: '#3b82f6', apology: '#f59e0b', feature: '#14b8a6', escalation: '#a855f7' };
const KEY_MAP = { '1': 'refund', '2': 'bug', '3': 'apology', '4': 'feature', '5': 'escalation' };
const MAX_CLAIMS = 15;
const MAX_POWERUPS = 3;
const BASE_SCORE = 100;
const COMBO_TIERS = [[20, 5], [10, 3], [5, 2]];
const POWERUP_TYPES = ['freeze', 'auto', 'supervisor', 'heal'];
const POWERUP_ICONS = { freeze: '\u2744\uFE0F', auto: '\u26A1', supervisor: '\uD83D\uDC51', heal: '\u2764\uFE0F' };
const POWERUP_LABELS = { freeze: '時間停止', auto: '自動応答', supervisor: 'SV得点2倍', heal: 'ライフ回復' };
const POWERUP_DURATION = { freeze: 5000, auto: 6000, supervisor: 8000, heal: 0 };
const LS_KEY = 'claimBusterHighScore';

// ===== Claim Data =====
const CLAIMS = {
  refund: [
    '購入した商品が届きません。返金してください。',
    '注文と違う商品が届きました。返金希望です。',
    '二重に請求されています。返金をお願いします。',
    'キャンセルしたのに課金されました。',
    '返品したのに返金がまだ反映されません。',
    '不良品が届きました。代金を返してください。',
    'サービスを解約したのに引き落とされています。',
    '無料トライアルで請求が来ました。',
    '間違えて購入しました。取り消したいです。',
    '割引が適用されていません。差額を返してください。'
  ],
  bug: [
    'ログインできません。パスワードは正しいはずです。',
    'アプリが起動直後にクラッシュします。',
    '画面が真っ白になって何も表示されません。',
    '検索結果が正しく表示されません。',
    'ファイルのアップロードが途中で止まります。',
    '通知が二重に届きます。',
    'データが保存されず消えてしまいます。',
    '特定のページだけエラーが出ます。',
    '文字化けして読めません。',
    '動画が再生できません。音声だけ流れます。'
  ],
  apology: [
    '対応が遅すぎます。もう3日待っています。',
    '前回と言っていることが違います。',
    '何度も同じ説明をさせないでください。',
    '約束した期日を過ぎています。',
    '以前の担当者の対応がひどかったです。',
    '問い合わせの返信がまだ来ません。',
    '待たされすぎてうんざりしています。',
    '御社のサービスにはがっかりしました。',
    'もっと丁寧に対応してもらえますか？',
    'この件で非常に不愉快な思いをしています。'
  ],
  feature: [
    'ダークモードを追加してほしいです。',
    'CSVエクスポート機能が欲しいです。',
    '多言語対応をお願いしたいです。',
    'モバイルアプリ版はありますか？',
    'カレンダー連携機能を追加してほしい。',
    'ショートカットキーを設定したいです。',
    'グラフ表示機能があると嬉しいです。',
    'チーム共有機能は予定にありますか？',
    'APIを公開してもらえませんか？',
    '通知のカスタマイズがしたいです。'
  ],
  escalation: [
    '責任者と話がしたいです。',
    '上司に代わってもらえますか？',
    'この対応では納得できません。上の方を。',
    'もう何度目ですか。マネージャーを出して。',
    '法的措置も検討しています。',
    '消費者センターに相談します。',
    'SNSで拡散しますよ。',
    '御社の対応を公開させていただきます。',
    'このままでは解約します。決裁者と話したい。',
    'これ以上は担当者レベルでは無理でしょう。'
  ]
};

// ===== Audio =====
let audioCtx = null;
function ensureAudio() {
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  return audioCtx;
}
function playSound(type) {
  try {
    const ctx = ensureAudio();
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.connect(gain);
    gain.connect(ctx.destination);
    const now = ctx.currentTime;
    switch (type) {
      case 'correct':
        osc.type = 'sine'; osc.frequency.setValueAtTime(523, now);
        osc.frequency.linearRampToValueAtTime(784, now + 0.1);
        gain.gain.setValueAtTime(0.15, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
        osc.start(now); osc.stop(now + 0.2);
        break;
      case 'wrong':
        osc.type = 'sawtooth'; osc.frequency.setValueAtTime(200, now);
        osc.frequency.linearRampToValueAtTime(100, now + 0.3);
        gain.gain.setValueAtTime(0.12, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
        osc.start(now); osc.stop(now + 0.3);
        break;
      case 'select':
        osc.type = 'sine'; osc.frequency.setValueAtTime(880, now);
        gain.gain.setValueAtTime(0.08, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.08);
        osc.start(now); osc.stop(now + 0.08);
        break;
      case 'levelup':
        osc.type = 'sine'; osc.frequency.setValueAtTime(523, now);
        osc.frequency.setValueAtTime(659, now + 0.1);
        osc.frequency.setValueAtTime(784, now + 0.2);
        osc.frequency.setValueAtTime(1047, now + 0.3);
        gain.gain.setValueAtTime(0.15, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
        osc.start(now); osc.stop(now + 0.5);
        break;
      case 'gameover':
        osc.type = 'sawtooth'; osc.frequency.setValueAtTime(440, now);
        osc.frequency.linearRampToValueAtTime(110, now + 0.6);
        gain.gain.setValueAtTime(0.12, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.6);
        osc.start(now); osc.stop(now + 0.6);
        break;
      case 'powerup':
        osc.type = 'sine'; osc.frequency.setValueAtTime(660, now);
        osc.frequency.setValueAtTime(880, now + 0.08);
        osc.frequency.setValueAtTime(1100, now + 0.16);
        gain.gain.setValueAtTime(0.12, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
        osc.start(now); osc.stop(now + 0.3);
        break;
    }
  } catch (e) { /* audio not available */ }
}

// ===== DOM =====
const $ = (sel) => document.querySelector(sel);
const $$ = (sel) => document.querySelectorAll(sel);
const titleScreen = $('#title-screen');
const gameScreen = $('#game-screen');
const gameArea = $('#game-area');
const hudScore = $('#hud-score');
const hudLevel = $('#hud-level');
const hudLives = $('#hud-lives');
const comboBadge = $('#combo-badge');
const pauseOverlay = $('#pause-overlay');
const levelClearOverlay = $('#level-clear-overlay');
const gameoverOverlay = $('#gameover-overlay');
const activePowerupsEl = $('#active-powerups');

// ===== State =====
const STATE = {
  screen: 'title',
  score: 0,
  level: 1,
  lives: 5,
  maxLives: 5,
  combo: 0,
  claims: [],
  powerups: [],
  selectedClaim: null,
  paused: false,
  gameOver: false,
  waveClaimsTotal: 0,
  waveClaimsSpawned: 0,
  waveClaimsCleared: 0,
  spawnTimer: 0,
  lastTime: 0,
  animFrameId: null,
  activePowerups: {},
  highScore: parseInt(localStorage.getItem(LS_KEY)) || 0,
  hudDirty: true,
  waveBonus: { time: 0, accuracy: 0, combo: 0 },
  waveStartTime: 0,
  waveCorrect: 0,
  waveAttempts: 0,
  maxComboThisWave: 0,
};

// ===== DOM Pool =====
const claimPool = [];
const powerupPool = [];

function getClaimEl() {
  let el = claimPool.pop();
  if (!el) {
    el = document.createElement('div');
    el.className = 'claim';
  }
  return el;
}
function releaseClaimEl(el) {
  el.classList.remove('selected', 'urgent', 'boss');
  el.style.cssText = '';
  el.innerHTML = '';
  if (el.parentNode) el.parentNode.removeChild(el);
  claimPool.push(el);
}
function getPowerupEl() {
  let el = powerupPool.pop();
  if (!el) {
    el = document.createElement('div');
    el.className = 'powerup';
  }
  return el;
}
function releasePowerupEl(el) {
  el.style.cssText = '';
  el.textContent = '';
  if (el.parentNode) el.parentNode.removeChild(el);
  powerupPool.push(el);
}

// ===== Screen Management =====
function showScreen(name) {
  STATE.screen = name;
  titleScreen.classList.toggle('active', name === 'title');
  gameScreen.classList.toggle('active', name === 'game');
}

// ===== High Score =====
function loadHighScore() {
  STATE.highScore = parseInt(localStorage.getItem(LS_KEY)) || 0;
  $('#title-highscore').textContent = STATE.highScore.toLocaleString();
}
function saveHighScore() {
  if (STATE.score > STATE.highScore) {
    STATE.highScore = STATE.score;
    localStorage.setItem(LS_KEY, STATE.highScore);
  }
}

// ===== HUD =====
function renderLives() {
  let html = '';
  for (let i = 0; i < STATE.maxLives; i++) {
    html += '<div class="life-pip' + (i >= STATE.lives ? ' lost' : '') + '"></div>';
  }
  hudLives.innerHTML = html;
}
function updateHUD() {
  if (!STATE.hudDirty) return;
  hudScore.textContent = STATE.score.toLocaleString();
  hudLevel.textContent = STATE.level;
  renderLives();
  const mult = getComboMultiplier();
  if (mult > 1) {
    comboBadge.textContent = 'x' + mult;
    comboBadge.classList.add('visible');
  } else {
    comboBadge.classList.remove('visible');
  }
  STATE.hudDirty = false;
}

// ===== Combo =====
function getComboMultiplier() {
  for (const [threshold, mult] of COMBO_TIERS) {
    if (STATE.combo >= threshold) return mult;
  }
  return 1;
}

// ===== Level Config =====
function getWaveCount(level) { return Math.min(5 + level * 2, 25); }
function getSpawnInterval(level) { return Math.max(2000 - level * 100, 600); }
function getClaimSpeed(level) { return 30 + level * 5; }
function hasUrgent(level) { return level >= 3; }
function hasBoss(level) { return level >= 5; }
function hasHorizontalMove(level) { return level >= 7; }

// ===== Claim Spawning =====
function pickClaim(level) {
  const cat = CATEGORIES[Math.floor(Math.random() * CATEGORIES.length)];
  const texts = CLAIMS[cat];
  const text = texts[Math.floor(Math.random() * texts.length)];
  const isUrgent = hasUrgent(level) && Math.random() < 0.2;
  const isBoss = hasBoss(level) && !isUrgent && Math.random() < 0.1;
  return { cat, text, urgent: isUrgent, boss: isBoss };
}

function spawnClaim() {
  if (STATE.claims.length >= MAX_CLAIMS) return;
  if (STATE.waveClaimsSpawned >= STATE.waveClaimsTotal) return;

  const areaRect = gameArea.getBoundingClientRect();
  const data = pickClaim(STATE.level);
  const el = getClaimEl();
  let html = '';
  if (data.urgent) html += '<div class="claim-badge urgent-badge">緊急</div>';
  if (data.boss) html += '<div class="claim-badge boss-badge">BOSS</div>';
  html += '<div>' + data.text + '</div>';
  el.innerHTML = html;
  if (data.urgent) el.classList.add('urgent');
  if (data.boss) el.classList.add('boss');

  const maxX = areaRect.width - 230;
  const x = 10 + Math.random() * Math.max(maxX, 10);
  const speed = getClaimSpeed(STATE.level) * (data.boss ? 0.6 : data.urgent ? 1.4 : 1);
  const hMove = hasHorizontalMove(STATE.level) ? (Math.random() - 0.5) * 40 : 0;

  const claim = {
    el, x, y: -100, speed, cat: data.cat,
    urgent: data.urgent, boss: data.boss,
    hMove, hPhase: Math.random() * Math.PI * 2,
    hp: data.boss ? 3 : 1, maxHp: data.boss ? 3 : 1
  };

  el.style.transform = 'translate(' + x + 'px, ' + claim.y + 'px)';
  gameArea.appendChild(el);
  STATE.claims.push(claim);
  STATE.waveClaimsSpawned++;
}

// ===== Power-Up Spawning =====
function spawnPowerup() {
  if (STATE.powerups.length >= MAX_POWERUPS) return;
  const areaRect = gameArea.getBoundingClientRect();
  const type = POWERUP_TYPES[Math.floor(Math.random() * POWERUP_TYPES.length)];
  const el = getPowerupEl();
  el.textContent = POWERUP_ICONS[type];
  const x = 20 + Math.random() * (areaRect.width - 60);
  const pu = { el, type, x, y: -50, speed: 40 };
  el.style.transform = 'translate(' + x + 'px, ' + pu.y + 'px)';
  gameArea.appendChild(el);
  STATE.powerups.push(pu);
}

// ===== Activate Power-Up =====
function activatePowerup(type) {
  playSound('powerup');
  if (type === 'heal') {
    STATE.lives = Math.min(STATE.lives + 1, STATE.maxLives);
    STATE.hudDirty = true;
    showFloatingText(gameArea.getBoundingClientRect().width / 2, gameArea.getBoundingClientRect().height / 2, '+1 HP', '#22c55e');
    return;
  }
  const dur = POWERUP_DURATION[type];
  if (STATE.activePowerups[type]) clearTimeout(STATE.activePowerups[type].timer);
  const timer = setTimeout(() => { deactivatePowerup(type); }, dur);
  STATE.activePowerups[type] = { timer, endTime: Date.now() + dur };
  renderActivePowerups();
}
function deactivatePowerup(type) {
  delete STATE.activePowerups[type];
  renderActivePowerups();
}
function renderActivePowerups() {
  let html = '';
  for (const type of Object.keys(STATE.activePowerups)) {
    const color = type === 'freeze' ? '#38bdf8' : type === 'auto' ? '#fbbf24' : type === 'supervisor' ? '#a855f7' : '#22c55e';
    html += '<div class="active-powerup-tag" style="background:' + color + '">' + POWERUP_ICONS[type] + ' ' + POWERUP_LABELS[type] + '</div>';
  }
  activePowerupsEl.innerHTML = html;
}

// ===== Visual Effects =====
function spawnParticles(x, y, color, count) {
  for (let i = 0; i < count; i++) {
    const p = document.createElement('div');
    p.className = 'particle';
    const size = 4 + Math.random() * 6;
    p.style.width = size + 'px';
    p.style.height = size + 'px';
    p.style.background = color;
    p.style.left = x + 'px';
    p.style.top = y + 'px';
    gameArea.appendChild(p);
    const angle = Math.random() * Math.PI * 2;
    const dist = 30 + Math.random() * 60;
    const dx = Math.cos(angle) * dist;
    const dy = Math.sin(angle) * dist;
    const duration = 400 + Math.random() * 300;
    p.animate([
      { transform: 'translate(0,0) scale(1)', opacity: 1 },
      { transform: 'translate(' + dx + 'px,' + dy + 'px) scale(0)', opacity: 0 }
    ], { duration, easing: 'ease-out', fill: 'forwards' }).onfinish = () => p.remove();
  }
}

function showFloatingText(x, y, text, color) {
  const el = document.createElement('div');
  el.className = 'score-popup';
  el.textContent = text;
  if (color) el.style.color = color;
  el.style.left = x + 'px';
  el.style.top = y + 'px';
  gameArea.appendChild(el);
  setTimeout(() => el.remove(), 800);
}

function screenShake() {
  gameArea.classList.add('screen-shake');
  setTimeout(() => gameArea.classList.remove('screen-shake'), 300);
}

// ===== Player Actions =====
function selectClaim(claim) {
  if (STATE.selectedClaim) STATE.selectedClaim.el.classList.remove('selected');
  STATE.selectedClaim = claim;
  claim.el.classList.add('selected');
  playSound('select');
}

function attemptResponse(cat) {
  if (!STATE.selectedClaim) return;
  const claim = STATE.selectedClaim;
  STATE.waveAttempts++;

  // Auto-respond power-up always correct
  const isCorrect = STATE.activePowerups.auto || claim.cat === cat;

  if (isCorrect) {
    claim.hp--;
    if (claim.hp <= 0) {
      destroyClaim(claim, true);
    } else {
      playSound('correct');
      const rect = claim.el.getBoundingClientRect();
      const areaRect = gameArea.getBoundingClientRect();
      showFloatingText(rect.left - areaRect.left + rect.width / 2, rect.top - areaRect.top, 'HIT!', CAT_COLORS[cat]);
    }
  } else {
    handleWrongAnswer(claim);
  }
  highlightToolbar(cat, isCorrect);
}

function destroyClaim(claim, correct) {
  const rect = claim.el.getBoundingClientRect();
  const areaRect = gameArea.getBoundingClientRect();
  const cx = rect.left - areaRect.left + rect.width / 2;
  const cy = rect.top - areaRect.top + rect.height / 2;

  if (correct) {
    STATE.combo++;
    STATE.waveCorrect++;
    if (STATE.combo > STATE.maxComboThisWave) STATE.maxComboThisWave = STATE.combo;
    const mult = getComboMultiplier();
    const svMult = STATE.activePowerups.supervisor ? 2 : 1;
    const posBonus = Math.floor((1 - (cy / areaRect.height)) * 50);
    const points = (BASE_SCORE + posBonus) * mult * svMult * (claim.boss ? 3 : claim.urgent ? 2 : 1);
    STATE.score += points;
    playSound('correct');
    spawnParticles(cx, cy, CAT_COLORS[claim.cat], claim.boss ? 20 : 10);
    showFloatingText(cx, cy, '+' + points, CAT_COLORS[claim.cat]);
  }

  if (STATE.selectedClaim === claim) STATE.selectedClaim = null;
  const idx = STATE.claims.indexOf(claim);
  if (idx !== -1) STATE.claims.splice(idx, 1);
  releaseClaimEl(claim.el);
  STATE.waveClaimsCleared++;
  STATE.hudDirty = true;
  checkWaveClear();
}

function handleWrongAnswer(claim) {
  STATE.combo = 0;
  STATE.lives--;
  STATE.hudDirty = true;
  playSound('wrong');
  screenShake();
  const rect = claim.el.getBoundingClientRect();
  const areaRect = gameArea.getBoundingClientRect();
  showFloatingText(rect.left - areaRect.left, rect.top - areaRect.top, 'MISS!', '#ef4444');
  if (STATE.selectedClaim === claim) {
    claim.el.classList.remove('selected');
    STATE.selectedClaim = null;
  }
  if (STATE.lives <= 0) gameOver();
}

function claimReachedBottom(claim) {
  STATE.combo = 0;
  STATE.lives--;
  STATE.hudDirty = true;
  playSound('wrong');
  screenShake();
  if (STATE.selectedClaim === claim) STATE.selectedClaim = null;
  const idx = STATE.claims.indexOf(claim);
  if (idx !== -1) STATE.claims.splice(idx, 1);
  releaseClaimEl(claim.el);
  STATE.waveClaimsCleared++;
  if (STATE.lives <= 0) gameOver();
}

function highlightToolbar(cat, correct) {
  const btn = document.querySelector('.tool-btn[data-cat="' + cat + '"]');
  if (!btn) return;
  btn.classList.add('selected');
  btn.style.background = correct ? 'rgba(34,197,94,0.2)' : 'rgba(239,68,68,0.2)';
  setTimeout(() => { btn.classList.remove('selected'); btn.style.background = ''; }, 200);
}

// ===== Wave Management =====
function startWave() {
  STATE.waveClaimsTotal = getWaveCount(STATE.level);
  STATE.waveClaimsSpawned = 0;
  STATE.waveClaimsCleared = 0;
  STATE.spawnTimer = 0;
  STATE.waveStartTime = Date.now();
  STATE.waveCorrect = 0;
  STATE.waveAttempts = 0;
  STATE.maxComboThisWave = 0;
  closeAllOverlays();
}

function checkWaveClear() {
  if (STATE.waveClaimsCleared >= STATE.waveClaimsTotal && STATE.waveClaimsSpawned >= STATE.waveClaimsTotal) {
    waveClear();
  }
}

function waveClear() {
  playSound('levelup');
  STATE.paused = true;

  // Calculate bonuses
  const timeElapsed = (Date.now() - STATE.waveStartTime) / 1000;
  const timeBonus = Math.max(0, Math.floor((60 - timeElapsed) * 10));
  const accuracy = STATE.waveAttempts > 0 ? STATE.waveCorrect / STATE.waveAttempts : 0;
  const accuracyBonus = Math.floor(accuracy * 200);
  const comboBonus = STATE.maxComboThisWave * 50;
  STATE.waveBonus = { time: timeBonus, accuracy: accuracyBonus, combo: comboBonus };
  STATE.score += timeBonus + accuracyBonus + comboBonus;
  STATE.hudDirty = true;

  // Life recovery every 3 levels
  const lifeRecovery = STATE.level % 3 === 0 && STATE.lives < STATE.maxLives;
  if (lifeRecovery) STATE.lives++;

  // Show overlay
  $('#clear-title').textContent = 'Wave ' + STATE.level + ' クリア！';
  let bonusHtml = '<div>タイムボーナス: <span>+' + timeBonus + '</span></div>';
  bonusHtml += '<div>正確性ボーナス: <span>+' + accuracyBonus + '</span> (' + Math.round(accuracy * 100) + '%)</div>';
  bonusHtml += '<div>コンボボーナス: <span>+' + comboBonus + '</span> (最大' + STATE.maxComboThisWave + '連続)</div>';
  if (lifeRecovery) bonusHtml += '<div style="color:#22c55e;font-weight:700;">HP回復 +1</div>';
  $('#bonus-list').innerHTML = bonusHtml;
  $('#clear-score').textContent = STATE.score.toLocaleString();
  levelClearOverlay.classList.add('active');
}

function nextWave() {
  STATE.level++;
  STATE.paused = false;
  STATE.hudDirty = true;
  startWave();
}

// ===== Game Over =====
function gameOver() {
  STATE.gameOver = true;
  STATE.paused = true;
  playSound('gameover');
  saveHighScore();
  $('#go-score').textContent = STATE.score.toLocaleString();
  $('#go-level').textContent = STATE.level;
  $('#go-highscore').textContent = STATE.highScore.toLocaleString();
  if (STATE.score >= STATE.highScore && STATE.score > 0) {
    $('#go-newrecord').style.display = 'block';
  } else {
    $('#go-newrecord').style.display = 'none';
  }
  gameoverOverlay.classList.add('active');
}

// ===== Game Loop =====
function gameLoop(time) {
  STATE.animFrameId = requestAnimationFrame(gameLoop);
  if (STATE.paused || STATE.gameOver) return;

  const dt = STATE.lastTime ? (time - STATE.lastTime) / 1000 : 0;
  STATE.lastTime = time;
  if (dt > 0.1) return; // skip large gaps

  const isFrozen = !!STATE.activePowerups.freeze;
  const areaRect = gameArea.getBoundingClientRect();
  const bottomY = areaRect.height - 10;

  // Spawn claims
  STATE.spawnTimer += dt * 1000;
  const interval = getSpawnInterval(STATE.level);
  if (STATE.spawnTimer >= interval && STATE.waveClaimsSpawned < STATE.waveClaimsTotal) {
    spawnClaim();
    STATE.spawnTimer = 0;
  }

  // Move claims
  if (!isFrozen) {
    for (let i = STATE.claims.length - 1; i >= 0; i--) {
      const c = STATE.claims[i];
      c.y += c.speed * dt;
      if (c.hMove) {
        c.hPhase += dt * 2;
        c.x += Math.sin(c.hPhase) * c.hMove * dt;
        c.x = Math.max(0, Math.min(c.x, areaRect.width - 230));
      }
      c.el.style.transform = 'translate(' + c.x + 'px,' + c.y + 'px)';
      if (c.y > bottomY) {
        claimReachedBottom(c);
      }
    }
  }

  // Move power-ups
  for (let i = STATE.powerups.length - 1; i >= 0; i--) {
    const p = STATE.powerups[i];
    p.y += p.speed * dt;
    p.el.style.transform = 'translate(' + p.x + 'px,' + p.y + 'px)';
    if (p.y > bottomY) {
      STATE.powerups.splice(i, 1);
      releasePowerupEl(p.el);
    }
  }

  // Random power-up spawn
  if (Math.random() < 0.001 + STATE.level * 0.0003) {
    spawnPowerup();
  }

  // Auto-respond power-up
  if (STATE.activePowerups.auto && STATE.claims.length > 0 && Math.random() < 0.03) {
    const randomClaim = STATE.claims[Math.floor(Math.random() * STATE.claims.length)];
    selectClaim(randomClaim);
    attemptResponse(randomClaim.cat);
  }

  updateHUD();
}

// ===== Start / Reset =====
function startGame() {
  // Clear state
  STATE.score = 0;
  STATE.level = 1;
  STATE.lives = 5;
  STATE.maxLives = 5;
  STATE.combo = 0;
  STATE.selectedClaim = null;
  STATE.paused = false;
  STATE.gameOver = false;
  STATE.lastTime = 0;
  STATE.hudDirty = true;
  STATE.activePowerups = {};
  renderActivePowerups();

  // Clear game area
  STATE.claims.forEach(c => releaseClaimEl(c.el));
  STATE.claims = [];
  STATE.powerups.forEach(p => releasePowerupEl(p.el));
  STATE.powerups = [];

  // Remove stale particles/popups
  gameArea.querySelectorAll('.particle, .score-popup').forEach(el => el.remove());

  closeAllOverlays();
  showScreen('game');
  startWave();

  if (STATE.animFrameId) cancelAnimationFrame(STATE.animFrameId);
  STATE.animFrameId = requestAnimationFrame(gameLoop);
}

function closeAllOverlays() {
  pauseOverlay.classList.remove('active');
  levelClearOverlay.classList.remove('active');
  gameoverOverlay.classList.remove('active');
}

function togglePause() {
  if (STATE.gameOver) return;
  if (levelClearOverlay.classList.contains('active')) return;
  STATE.paused = !STATE.paused;
  if (STATE.paused) {
    pauseOverlay.classList.add('active');
  } else {
    pauseOverlay.classList.remove('active');
    STATE.lastTime = 0;
  }
}

function goToTitle() {
  if (STATE.animFrameId) cancelAnimationFrame(STATE.animFrameId);
  STATE.claims.forEach(c => releaseClaimEl(c.el));
  STATE.claims = [];
  STATE.powerups.forEach(p => releasePowerupEl(p.el));
  STATE.powerups = [];
  Object.keys(STATE.activePowerups).forEach(t => {
    clearTimeout(STATE.activePowerups[t].timer);
  });
  STATE.activePowerups = {};
  renderActivePowerups();
  gameArea.querySelectorAll('.particle, .score-popup').forEach(el => el.remove());
  closeAllOverlays();
  saveHighScore();
  loadHighScore();
  showScreen('title');
}

// ===== Event Handlers =====
// Game area click delegation
gameArea.addEventListener('click', function(e) {
  if (STATE.paused || STATE.gameOver) return;

  // Check power-up click
  for (let i = STATE.powerups.length - 1; i >= 0; i--) {
    const p = STATE.powerups[i];
    if (p.el.contains(e.target)) {
      activatePowerup(p.type);
      STATE.powerups.splice(i, 1);
      releasePowerupEl(p.el);
      return;
    }
  }

  // Check claim click
  for (const c of STATE.claims) {
    if (c.el.contains(e.target)) {
      selectClaim(c);
      return;
    }
  }
});

// Toolbar click delegation
$('#toolbar').addEventListener('click', function(e) {
  const btn = e.target.closest('.tool-btn');
  if (!btn) return;
  const cat = btn.dataset.cat;
  if (cat) attemptResponse(cat);
});

// Keyboard
document.addEventListener('keydown', function(e) {
  if (STATE.screen === 'title') {
    if (e.code === 'Space') { e.preventDefault(); startGame(); }
    return;
  }

  if (STATE.screen !== 'game') return;

  // Level clear: Enter/Space to continue
  if (levelClearOverlay.classList.contains('active')) {
    if (e.code === 'Space' || e.code === 'Enter') { e.preventDefault(); nextWave(); }
    return;
  }

  // Game over: Enter/Space to retry
  if (gameoverOverlay.classList.contains('active')) {
    if (e.code === 'Space' || e.code === 'Enter') { e.preventDefault(); startGame(); }
    return;
  }

  if (e.key === 'p' || e.key === 'P' || e.code === 'Escape') {
    e.preventDefault();
    togglePause();
    return;
  }

  if (STATE.paused) return;

  const cat = KEY_MAP[e.key];
  if (cat) {
    e.preventDefault();
    attemptResponse(cat);
  }
});

// Buttons
$('#btn-start').addEventListener('click', startGame);
$('#btn-pause').addEventListener('click', togglePause);
$('#btn-resume').addEventListener('click', togglePause);
$('#btn-to-title').addEventListener('click', goToTitle);
$('#btn-next-wave').addEventListener('click', nextWave);
$('#btn-retry').addEventListener('click', startGame);
$('#btn-go-title').addEventListener('click', goToTitle);

// ===== Init =====
loadHighScore();

})();
</script>
</body>
</html>
